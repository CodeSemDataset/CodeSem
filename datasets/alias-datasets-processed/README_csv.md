# 别名信息输出格式

1. 输出的别名信息分为True_Alias_Pairs和False_Alias_Pairs：

   True_Alias_Pairs：LLVM输出的正确别名对，两个变量间存在别名关系；

   False_Alias_Pairs：LLVM输出的错误别名对，即LLVM错误认定两个不存在别名关系的变量互为别名；

2. csv文件中的别名信息按照行号依次成对，并由两个标识行分为True_Alias_Pairs和False_Alias_Pairs两个部分，标识行指的是只存在一列，且该列内容为" True_Alias_Pairs "或" False_Alias_Pairs "的整行；

   第2行为True_Alias_Pairs标识行，则3，4两行构成LLVM输出的正确别名对信息，同理5，6行构成别名对，以此类推，直到False_Alias_Pairs标识行上方一行为止；

   同理，假设第100行为False_Alias_Pairs标识行，则101，102行构成LLVM输出的错误别名对信息，103，104行构成错误别名对，以此类推，直到当前csv文件末尾；

3. 输出的csv文件格式如下（部分别名未找到所属函数或use点信息，因此对应列为空）

| 列号 | 内容             |
| ---- | ---------------- |
| 1    | 别名名称         |
| 2    | 所在目录         |
| 3    | 所在文件行号     |
| 4    | 所属函数名       |
| 5    | 所属函数行号范围 |
| 6+   | use点属性        |

其中use点输出格式为：

**（序号，行号，列号）具体命令**

e.g. `(1;123;33)  %62 = load i8*, i8** %dst.addr, align 8, !dbg !31586`

即表明该别名use点序号为1，处于123行33列，括号外的部分为具体命令



序号（Position_No）指的是该use点是该变量在函数中出现的第几次，如下图：

```
for(int i = 1; i< 10 ; i++){
	... ...
}
int i = 4;
```

两个 **i** 并非同一变量，但`int i = 4`中的 **i** 序号应当为2，即同名变量在计算use点序号时也需要被纳入计算；

目前序号并未实现（暂时全部输出为0），由于DILocation无法准确输出所有命令的行号，因此无法通过排序来确定use点序号。